\documentclass[12pt]{article} % article?
\usepackage{geometry} %
\geometry{a4paper} % or letter or a5paper or ... etc
\usepackage{graphicx}
\usepackage{amssymb,amsmath, bm}
\geometry{letterpaper, top=1in, left=1in, right=1in, bottom=1in} % to set margins

\usepackage{setspace}
\onehalfspacing

\title{Using {\tt pomp} to model pathogen interactions}
\author{Nicholas G Reich}

%%% BEGIN DOCUMENT
\begin{document}

%opts_chunk$set(concordance=TRUE, tidy=TRUE)

\maketitle


\section{The disease transmission model}
We specify a model for a univariate time series, measured in discrete time units. Say that $Y_{i,t}$ are the number of observed cases of disease $i$ within a particular time window $t$. Furthermore, $X_{i,t}$ are the total number of cases occuring in time $t$. The theoretical transmission model (adapted from Finkenstadt and Grenfell) could be written as
\begin{equation}
X_{i,t} = \beta_t \cdot X_{i,t-1}^{\alpha_1} \cdot S_{i,t-1}^{\alpha_2}
\end{equation}
where $S_{i,t}$ is the number of susceptible individuals to disease $i$ at time $t$ and 
% lifted from supplemental materials of JRSI paper
the $\beta_t$ are a time-varying transmission parameters.  
The $\alpha$ are mixing parameters, which, if both equal 1, define a population with homogeneous mixing whereas values not equal to 1 have been used to describe departures from mass-action mixing 
%\cite{liu1987dynamical} 
and to account for discretization of continuous time transmission processes 
%\cite{glass2003interpreting}
.


Therefore, a statistical formulation of the theoretical transmission model would be
\begin{eqnarray}
\log {\mathbb E}[ X_{i,t}|X_{\cdot,t-1}, S_{i,t-1}] & = & \log\beta_t + \alpha_1 \log X_{t-1} + \alpha_2 \log S_{i,t-1}
\end{eqnarray}
where the $\beta_t$ coefficients represent the seasonal baselines, i.e. $\beta_t = \beta_{t \mod 26}$ if our timestep is biweeks, and $p_t$ are time-varying case-reporting probabilities. We intentionally leave the distributional assumption for $X_{i,t}$ unspecified for now, although it would likely be specified as Poisson or Negative Binomial.

The heart of this model resides in our definition of the $S_{i,t}$. In the past, we have defined this measure of susceptibility along these lines:
\begin{eqnarray}
S_{i,t} & = &  B_{t-d} + S_{i,t-1} - I_{i,t} - \delta \cdot Q_{-i,t} \label{eq:generalSuscModel}
%S_{i,t} & = & S_{i,t-1} + B_{t-d} - I_{i,t} -\delta\sum_{j\neq i}[I_{j,t-1}- I_{j,t-(k+1)}]. 
\end{eqnarray}
where the $Q_{-i,t}$ term may take on different forms depending on the mechanistic process assumed about how individuals enter and leave the pool of susceptible individuals based on cross-protection and enhancement. For the moment, we might assume a model with a fixed duration of cross-protection, in which case, $Q_{-i,t}(k) = \sum_{j\neq i}[I_{j,t-1}- I_{j,t-(k+1)}]$ where $Q$ depends on  $k$ is the fixed duration of cross protection.

Based on the above formulation, we can write a process simulator function based on the {\tt pomp} package format.
<<processSimulatorDefine, message=FALSE>>=
require(pomp)
proc.sim <- function(x, t, params, delta.t, ...) {
        ## unpack the params vector:
        ##  biweek
        biweek <- params["biweek"]
        beta.string <- paste0("beta", biweek)
        ## beta1, ...., beta26
        beta_t <- params[beta.string]
        ## alpha1 and alpha2
        alpha1 <- params["alpha1"]
        alpha2 <- params["alpha2"]
        ## CP params: delta and k
        delta <- params["delta"]
        k <- params["k"]
        ## state at time t:
        X <- x["X"]
        ## compute the state at time t+delta.t
        log.lambda <- beta*log(X) + alpha
        xnew <- c(X=unname( rpois(n=1, lambda=exp(log.lambda)) ))
        return(xnew)
}
@

\section{The model for an observation process}
And the observation process could be modeled as 
\begin{eqnarray}
Y_{i,t} | X_{i,t} & \sim & Binomial(p_{i,t}, X_{i,t})
%\bm{Y_t} | \bm{X_t} & \sim & Multinomial(\bm{p_t}, N_t)
\end{eqnarray}
where the $p_{i,t}$ are calculated based on, say, a standard susceptible reconstruction. It would probably even be more accurate to say that $p_{i,t}\sim Beta(a,b)$ such that the mean of the beta distribution is equal to that of the estimated $p$ from the susceptible reconstruction, and the variance is equal to that of resulting from the fit.
%some known disease-specific reporting fractions that are varying over time and $N_t$ is the total number of cases of any disease under consideration observed at time $t$. For example, we observe four under-reported serotype-specific case counts over time (the $Y_{i,t}$, or more succinctly, the $\bm{Y_t}$ and one total case count ($N_t$). Then, the $\bm{p_t}$ could be estimated by $p_{i,t} = \frac{Y_{i,t}}{N_t}$. 

\section{A simple cross-protection model}
Let's start with a similar but simpler version of the model presented above:
\begin{eqnarray}
\log {\mathbb E}[ X_{i,t}|X_{\cdot,t-1}, S_{i,t-1}] & = & \log\beta + \alpha_1 \log X_{t-1} + \alpha_2 \log S_{i,t-1}\\
S_{i,t} & = &  B + S_{i,t-1} - \sum_j I_{j,t} +  \\
C_{i,t} & = &  C_{i,t-1} + \sum{j \neq i}X_{j,t}\\
Q_{-i,t} & = &  \sum_{j\neq i}[I_{j,t-1}- I_{j,t-(k+1)}]
\end{eqnarray}
Major departures from above models:
\begin{itemize}
\item Assume only two strains.
\item Assume $\beta$ is constant.
\item Assume births are constant B.
\item assume k is known and equals 2.
\end{itemize}

<<simpleProcSim>>=
toy.proc.sim <- function(x, t, params, delta.t, ...) {
        ## unpack the params vector:
        beta <- params["beta"]
        alpha1 <- params["alpha1"]
        alpha2 <- params["alpha2"]
        lambda <- params["lambda"]
        mu <- params["mu"]
        N <- params["N"]
        iota <- params["iota"]
        ## CP params: delta and k
        delta <- params["delta"]
        k <- params["k"]
        ## copy x for easy access
        newx <- x
        ## transitions for strain 1
        newx["I1"] <- rpois(1, beta*((x["I1"]/N+iota)^alpha1)*(x["S1"]^alpha2))
        C1.loss <- rpois(1, lambda*x["C1"]) ## Poisson approximation to exponential loss from C1
        ## transitions for strain 2
        newx["I2"] <- rpois(1, beta*((x["I2"]/N+iota)^alpha1)*(x["S2"]^alpha2))
        C2.loss <- rpois(1, lambda*x["C2"]) ## Poisson approximation to exponential loss from C2
        ## udpate counts
        newx["S1"] <- x["S1"] + N*mu - newx["I1"] - newx["I2"] + C1.loss
        newx["S2"] <- x["S2"] + N*mu - newx["I2"] - newx["I1"] + C2.loss
        newx["C1"] <- x["C1"] - C1.loss + newx["I2"]
        newx["C2"] <- x["C2"] - C2.loss + newx["I1"]
        return(newx[c("S1", "I1", "C1", "S2", "I2", "C2")])
}

toy.meas.sim <- function(x, t, params, ...) {
        unname(x["I1"], x["I2"])
}
@

And now we can simulate this framework
<<simulateToyTSIR, cache=TRUE>>=
simulate(
        pomp(
                data=data.frame(
                        time=seq(0, 1000,by=1),
                        y1=NA
                ),
                times="time",
                t0=0,
                rprocess=discrete.time.sim(
                        step.fun=toy.proc.sim,
                        delta.t=1
                ),
                rmeasure=toy.meas.sim,
                ic.pars=c("S1.0","I1.0","C1.0", 
                          "S2.0","I2.0","C2.0"), # initial condition parameters 
                comp.names=c("S1","I1","C1", "S2","I2","C2") # names of the compartments
        ),
        params=c(
                N=50000,
                mu=1/50,
                beta=1.2,alpha1=1,alpha2=1,
                iota=1/1000,
                lambda=1/10,
                S1.0=40000,I1.0=500,C1.0=100,
                S2.0=40000,I2.0=2000,C2.0=100
        ),
        seed=677573454L
) -> tsir
plot(tsir, variables=c("I1","I2", "C1", "S1", "S2","C2"))
@
\end{document}